
#pragma once

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <thread>
#include <math.h>
#include <float.h>
#include <shellapi.h>
#include <Gdiplus.h>
#include <assert.h>
#include <algorithm>
#include <list>
#include <map>
#include <set>
#include <string>
#include <vector>
#include <functional>
#include <random>
#include <intrin.h>
#include <winres.h>
#include <TlHelp32.h>
#include <future>
#include <winternl.h>
#include <iostream>

enum THREADINFOCLASSX
{
	ThreadQuerySetWin32StartAddress = 9,
};

typedef NTSTATUS(__stdcall* f_NtQueryInformationThread)(HANDLE, THREADINFOCLASSX, void*, ULONG_PTR, ULONG_PTR*);

ULONG_PTR GetThreadStartAddress(HANDLE hThread)
{
	auto NtQueryInformationThread = reinterpret_cast<f_NtQueryInformationThread>(GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationThread"));
	if (!NtQueryInformationThread)
		return 0;

	ULONG_PTR ulStartAddress = 0;
	NTSTATUS Ret = NtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress, &ulStartAddress, sizeof(ULONG_PTR), nullptr);

	if (Ret)
		return 0;

	return ulStartAddress;
}


bool SuspendThread(ULONG_PTR StartAddress, DWORD dwProcId)
{
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (!hSnap)
		return false;

	THREADENTRY32 TE32 = { 0 };
	TE32.dwSize = sizeof(THREADENTRY32);

	BOOL Ret = Thread32First(hSnap, &TE32);
	while (Ret)
	{
		if (TE32.th32OwnerProcessID == dwProcId)
		{
			HANDLE hTempThread = OpenThread(THREAD_ALL_ACCESS, FALSE, TE32.th32ThreadID);
			if (!hTempThread)
				continue;

			if (StartAddress == GetThreadStartAddress(hTempThread))
			{
				SuspendThread(hTempThread);
				CloseHandle(hTempThread);
				CloseHandle(hSnap);
				return true;
			}
		}
		Ret = Thread32Next(hSnap, &TE32);
	}

	CloseHandle(hSnap);

	return false;
}

uintptr_t dwGetModuleBaseAddress(DWORD procId, const char* modName)
{
	uintptr_t modBaseAddr = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 modEntry;
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry))
		{
			do
			{
				if (strcmp(modEntry.szModule, modName) == 0)
				{
					modBaseAddr = (uintptr_t)modEntry.modBaseAddr;
					break;
				}
			} while (Module32Next(hSnap, &modEntry));

		}
	}
	CloseHandle(hSnap);
	return modBaseAddr;
}
DWORD FindProcessId(const std::string& processName)
{
	PROCESSENTRY32 processInfo;
	processInfo.dwSize = sizeof(processInfo);

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
		return 0;

	Process32First(processesSnapshot, &processInfo);
	if (!processName.compare(processInfo.szExeFile))
	{
		CloseHandle(processesSnapshot);
		return processInfo.th32ProcessID;
	}

	while (Process32Next(processesSnapshot, &processInfo))
	{
		if (!processName.compare(processInfo.szExeFile))
		{
			CloseHandle(processesSnapshot);
			return processInfo.th32ProcessID;
		}
	}

	CloseHandle(processesSnapshot);
	return 0;
}


int main()
{
	setlocale(LC_ALL, "Turkish");
	system("color 3");

	//Wait a second.
	std::cout << "İşlem Başlatıldı, Lütfen Birkaç Saniye Bekleyin...\n";
	std::cout << "sfrp-plugin == 0x14480(MAIN) \n";
	Sleep(5000);
	HWND Class = NULL;
	HANDLE hProcess;
	DWORD PID = FindProcessId("gta_sa.exe");

	if (PID == NULL)
	{
		//gta_sa.exe must be opened.
		std::cout << "gta_sa.exe açık olmalıdır!\n";
		Sleep(3000);
		exit(2);
	}
	else {
		//success.
		std::cout << "İşlem Başarıyla Tamamlandı, Sobeiti İnjecte Edebilirsiniz.\n";
		Sleep(10000);
		exit(2);
	}

	GetWindowThreadProcessId(Class, &PID);
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
	
	//FOR EXAMPLE
	DWORD base = dwGetModuleBaseAddress(PID, "sfrp-plugin.dll");
	DWORD base2 = dwGetModuleBaseAddress(PID, "sfrp-plugin.asi");

	//FOR EXAMPLE
	SuspendThread(base + 0x14480, PID); // -> Plugin Thread [0x14480]
	SuspendThread(base + 0x17550, PID);
	SuspendThread(base + 0x18270, PID); 
	SuspendThread(base + 0x21910, PID);
	SuspendThread(base + 0x7de0, PID); 
	SuspendThread(base + 0x8cc0, PID); 
	SuspendThread(base + 0x14390, PID);
	SuspendThread(base + 0x18020, PID); 
	SuspendThread(base + 0x21480, PID); 

	SuspendThread(base2 + 0x14480, PID); 
	SuspendThread(base2 + 0x17550, PID); 
	SuspendThread(base2 + 0x18270, PID); 
	SuspendThread(base2 + 0x21910, PID);
	SuspendThread(base2 + 0x7de0, PID); 
	SuspendThread(base2 + 0x8cc0, PID); 
	SuspendThread(base2 + 0x14390, PID); 
	SuspendThread(base2 + 0x18020, PID); 
	SuspendThread(base2 + 0x21480, PID);
}

